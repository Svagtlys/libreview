import requests

DEFAULT_ENDPOINT = "https://api{}.libreview.io"

# KNOWN_ENDPOINTS = [
#     "https://api.libreview.io",
#     "https://api-us.libreview.io",
#     "https://api-eu.libreview.io",
#     "https://api-eu2.libreview.io",
# ]

POSSIBLE_ADD_ENDPOINTS = {
    "login": "/llu/auth/login",
    "terms": "/auth/continue/tou",
    "user": "/user",
    "account": "/account",
    "connections": "/llu/connections",
    "graph": "/llu/connections/{patientID}/graph",
    "logbook": "/llu/connections/{patientID}/logbook",
    "notifications": "/llu/notifications/settings/{connectionID}",
    "config": "/llu/config/country",
}


HEADERS = {
    # required headers
    "accept-encoding": "gzip",
    "cache-control": "no-cache",
    "connection": "Keep-Alive",
    "content-type": "application/json",
    "product": "llu.android",
    "version": "4.8.0"
    # the version could change as the app is updated, might add option to change this in config
}


class LibreView:
    """Creates a LibreView object that represents one patient's data"""

    def __init__(self, email: str, password: str) -> None:
        """Initialize."""

        self._endpoint = DEFAULT_ENDPOINT.format("")
        self._email = email
        self._password = password
        self._patientID = None
        self._connectionID = None
        self._token = None

    async def authenticate(self) -> bool:
        """Test if we can authenticate with the LibreView API."""
        # login post
        requestData = {"email": self._email, "password": self._password}
        try:
            result = requests.post(
                url=self._endpoint + POSSIBLE_ADD_ENDPOINTS["login"],
                headers=HEADERS,
                json=requestData,
                timeout=5,
            )
        except (requests.Timeout, requests.ConnectionError):
            raise

        data = result.json()

        # Read data
        if data.get("status") and data.get("status") != 0:
            if data.get("status") == 2:
                # Bad login details
                return False
            if data.get("status") == 4:
                # TOU acceptance required, manual intervention at this time
                raise TOUException
            raise requests.ConnectionError

        if (
            data.get("data").get("redirect")
            and data.get("data").get("redirect") == True
        ):
            # Got redirect message, try redirect and return result of that.
            self._endpoint = DEFAULT_ENDPOINT.format("-" + data["data"]["region"])
            return await self.authenticate(self)

        if data.get("data").get("authTicket").get("token"):
            self._token = data["data"]["authTicket"]["token"]
            return True

        return False

    # Runs get request to acquire data containing patient ID, returns bool: success | fail, str: token | error message, str: patientID
    async def getPatientID(self) -> bool:
        # patientID get
        token_header = HEADERS | {"authorization": "Bearer " + self._token}
        try:
            result = requests.get(
                url=self._endpoint + POSSIBLE_ADD_ENDPOINTS["connections"],
                headers=token_header,
                timeout=5,
            )
        except requests.Timeout:
            raise
        except requests.ConnectionError:
            raise

        data = result.json()

        # data['data'] is a list of dicts

        # Read data
        if data.get("status") and data.get("status") != 0:
            return False

        if data.get("ticket").get("token") and data.get("data")[0].get("patientId"):
            # good return
            self._token = data["ticket"]["token"]
            self._patientID = data["data"][0]["patientId"]
            return True

        return False

    # Runs get request to acquire graph data, returns bool: success | fail, str: token | error message, str: data
    async def getGraph(self) -> list:
        # graph get
        token_header = HEADERS | {"authorization": "Bearer " + self._token}

        try:
            result = requests.get(
                url=self._endpoint
                + POSSIBLE_ADD_ENDPOINTS["graph"].format(patientID=self._patientID),
                headers=token_header,
                timeout=5,
            )
        except (requests.Timeout, requests.ConnectionError):
            raise

        data = result.json()

        # data['data'] is a dict

        # Read data
        if data.get("status") and data.get("status") != 0:
            return False, {}

        if (
            data.get("data").get("redirect")
            and data.get("data").get("redirect") == True
        ):
            # Got redirect message
            return False, {}
        if data.get("ticket").get("token") and data.get("data").get("graphData"):
            # good return
            self._token = data["ticket"]["token"]
            return data["data"]["graphData"]

        return False, {}

    # Runs get request to acquire logbook data, returns bool: success | fail, str: token | error message, str: data
    # Avoid using as this returns a loooooong list of entries
    async def getLogbook(self) -> list:
        # logbook get
        token_header = HEADERS | {"authorization": "Bearer " + self._token}

        try:
            result = requests.get(
                url=self._endpoint
                + POSSIBLE_ADD_ENDPOINTS["logbook"].format(patientID=self._patientID),
                headers=token_header,
                timeout=5,
            )
        except requests.Timeout:
            raise
        except requests.ConnectionError:
            raise

        data = result.json()

        # data['data'] is a list of dicts

        # Read data
        if data.get("status") and data.get("status") != 0:
            return []
        if data.get("ticket").get("token") and data.get("data"):
            # good return
            self._token = data["ticket"]["token"]
            return data["data"]

        return []

    # def async getLatestData(self) libreview.getLatestData() -> latest data (using timestamp)


class TOUException(Exception):
    """Raised when TOU needs to be accepted manually"""
